[manifest]
version = "1.0.0"
dump_lua = true
priority = -1

[[patches]]
[patches.pattern]
target = "main.lua"
pattern = '''function love.load()'''
position = "before"
payload = '''
Entropy = {}
Entropy.FlipsideInversions = {}
Entropy.EnhancementFuncs = {}
Entropy.RarityChecks = {
    [0]="cry_candy",
    1,
    2,
    3,
    "cry_epic",
    4,
    "cry_exotic",
    "entr_entropic"
}
Entropy.BoosterSets = {
    ["Spectral"] = "p_spectral_mega_1",
    ["Tarot"] = "p_arcana_mega_1",
    ["Planet"] = "p_celestial_mega_1",
    ["Spectral"] = "p_spectral_mega_1",
    ["Code"] = "p_cry_code_mega_1",
    ["RCode"] = "p_entr_twisted_pack_mega",
    ["RPlanet"] = "p_entr_twisted_pack_mega",
    ["RSpectral"] = "p_entr_twisted_pack_mega",
}
Entropy.DefineBlacklist = {
    c_black_hole = true,
    c_soul = true,
    c_cry_gateway = true,
    c_cry_white_hole = true,
    c_cry_pointer = true,
    c_entr_fervour = true,
    c_entr_define = true,
    Back = true,
    Sleeve = true,
    Edition = true
}

Entropy.ChaosBlacklist = {}
Entropy.ParakmiBlacklist = {}
Entropy.ChaosConversions = {}
Entropy.AscendedTags = {}
Entropy.BlindTokenBlacklist = {
  bl_entr_endless_entropy_phase_one = true,
  bl_entr_endless_entropy_phase_two = true,
  bl_entr_endless_entropy_phase_three = true,
  bl_entr_endless_entropy_phase_four = true
}
Entropy.References = {}
Entropy.Zeniths = {
  "j_entr_ruby"
}
Entropy.RarityPoints = {
    [1] = 1, --common
    [2] = 4, --uncommon
    [3] = 12, --rare
    ["cry_epic"] = 60,
    [4] = 300, --legendary
    ["cry_exotic"] = 1000,
    ["entr_entropic"] = 5000,
}
--higher rarities give less points so the diminisher is used in division
Entropy.RarityDiminishers = {
    [1] = 1,
    [2] = 1.5,
    [3] = 2.5,
    [4] = 5,
    ["cry_epic"] = 4,
    ["cry_exotic"] = 10,
    ["entr_entropic"] = 15
}
Entropy.EditionFactors = {
    ["e_foil"] = 1.25,
    ["e_holo"] = 1.45,
    ["e_polychrome"] = 2,
    ["e_negative"] = 2.1,
    ["e_cry_glitched"] = 1.4,
    ["e_cry_mosaic"] = 2.2,
    ["e_cry_oversaturated"] = 1.5,
    ["e_cry_fragile"] = 1.8,
    ["e_cry_gold"] = 1.7,
    ["e_cry_blurred"] = 1.5,
    ["e_cry_noisy"] = 1.7,
    ["e_cry_astral"] = 2.2,
    ["e_cry_m"] = 1.45
}
Entropy.SegFaultBlacklist = {
  entr_entropic = true,
  cry_exotic = true,
  [4] = true
}
Entropy.ConsumablePackBlacklist = {
  p_mupack_multipack1=true,
  p_mupack_multipack2=true,
  p_mupack_multipack3=true,
  p_mupack_multipack4=true,
  p_mupack_multipack5=true,
}
Entropy.RareInversions = {
  "c_entr_fervour",
  "c_entr_define",
  "c_entr_quasar",
  "c_entr_pulsar",
  "c_entr_beyond"
}
Entropy.FixedRecipes = {
    c_basec_basec_basec_basec_base = "j_joker",
    m_steelm_steelm_steelm_steelm_steel = "j_cry_clockwork"
}
Entropy.EnhancementPoints ={
    m_entr_disavowed=0,
    c_base=1,
    m_bonus=3.1,
    m_mult=3.2,
    m_wild=4.1,
    m_lucky=4.2,
    m_stone=5.1,
    m_entr_flesh=5.2,
    m_steel=6.1,
    m_gold=6.2,
    m_cry_echo=6.3,
    m_glass=7.1,
    m_cry_light=7.2,
    m_cry_abstract=9.1,
    m_entr_prismatic = 20
}
Entropy.TMTrainerEffects = {}
Entropy.TMTrainerScoring = {}
'''
match_indent = true


[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''(self.ability.set == 'Voucher' and {G.C.SECONDARY_SET.Voucher, G.C.CLEAR}) or'''
position = "at"
payload = '''
(self.ability.set == 'Voucher' and {G.C.SECONDARY_SET.Voucher, G.C.CLEAR}) or (G.C.Entropy.Dissolve[self.ability.set] and {G.C.Entropy.Dissolve[self.ability.set]}) or
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "card_character.lua"
pattern = 'self.children.card:set_ability(G.P_CENTERS.j_jolly)'
position = "after"
payload = "self.children.card:set_ability(G.P_CENTERS.j_entr_surreal_joker)"
match_indent = true

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = 'Cryptid.profile_prefix = "M"'
position = "after"
payload = 'Cryptid.profile_prefix = Cryptid.profile_prefix == "M" and "E" or Cryptid.profile_prefix.."E"'
match_indent = true

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = 'Cryptid.profile_prefix = Jen and "J" or "M"'
position = "after"
payload = 'Cryptid.profile_prefix = Cryptid.profile_prefix == "M" and "E" or Cryptid.profile_prefix.."E"'
match_indent = true


[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "          G.GAME.stake > 1 and {"
position = "before"
payload = '''
        {
          label = G.GAME.DefineKeys and localize('b_definitions'),
          tab_definition_function = G.GAME.DefineKeys and G.UIDEF.define_keys or nil,
        },
        {
          label = G.GAME.entr_bought_decks and #G.GAME.entr_bought_decks > 0 and localize('b_decks') or nil, 
          tab_definition_function = G.GAME.entr_bought_decks and #G.GAME.entr_bought_decks > 0 and G.UIDEF.bought_decks or nil,
        },'''
match_indent = true

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "self.GAME.starting_deck_size = #G.playing_cards"
position = "before"
payload = '''
if G.GAME.modifiers.ccd2 then
    for k, v in pairs(G.playing_cards) do
        local key = ""
        local ptype = pseudorandom_element({
            "Booster",
            "Voucher",
            "Tarot",
            "Joker",
            "Consumeable",
        }, pseudoseed("segfault"))
        if ptype == "Consumeable" then
            key = G.P_CENTERS[Cryptid.random_consumable("entr_segfault", nil, "c_entr_segfault").key]
            while key.set ~= ptype or key.no_doe or G.GAME.banned_keys[key.key] do
              key = G.P_CENTERS[Cryptid.random_consumable("entr_segfault", nil, "c_entr_segfault").key]
            end
            key = key.key
        else
            key = pseudorandom_element(G.P_CENTERS, pseudoseed("segfault"))
            local tries = 0
            while key.set ~= ptype or key.no_doe or G.GAME.banned_keys[key.key] do --i love when my key has keys
                key = pseudorandom_element(G.P_CENTERS, pseudoseed("segfault"))
                tries = tries + 1
            end
            key = key.key
        end
        v:set_ability(G.P_CENTERS[key])
    end
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "G.GAME.round_resets.ante = Big and (to_number(math.floor(to_big(G.GAME.round_resets.ante)))) or math.floor(G.GAME.round_resets.ante)"
position = "at"
payload = '''

'''
match_indent = true

[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = '''self.chips = get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling'''
position = "before"
payload = '''
if (not self.exponent) or self.exponent[2] <= 0 then
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = '''self.mult = blind and blind.mult or 0'''
position = "after"
payload = '''
self.exponent = blind and blind.exponent or {1,0}
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = '''self.chips = get_blind_amount(G.GAME.round_resets.ante)*self.mult*G.GAME.starting_params.ante_scaling'''
position = "after"
payload = '''
elseif self.exponent[2] > 0 then
    local initial = to_big(get_blind_amount(G.GAME.round_resets.ante)*G.GAME.starting_params.ante_scaling)
    initial = initial:arrow(self.exponent[1], self.exponent[2])
    self.chips = initial
end
'''
match_indent = true

### display exponential blind 2
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''        ability_text[1] and {n=G.UIT.R, config={align = "cm", padding = 0.08, colour = mix_colours(blind.boss_colour, G.C.GREY, 0.4), r = 0.1, emboss = 0.05, minw = 2.5, minh = 0.9}, nodes=ability_text} or nil
      }}'''
position = "after"
payload = '''
end
'''
match_indent = true

### display exponential blind 3
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''local blind_amt = get_blind_amount(G.GAME.round_resets.blind_ante)*blind_choice.config.mult*G.GAME.starting_params.ante_scaling'''
position = "after"
payload = '''
if blind_choice.config.exponent then
      local initial = get_blind_amount(G.GAME.round_resets.ante)*G.GAME.starting_params.ante_scaling
      initial = initial:arrow(blind_choice.config.exponent[1], blind_choice.config.exponent[2])
      blind_amt = initial
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''local stake_sprite = get_stake_sprite(G.GAME.stake or 1, 0.4)'''
position = "after"
payload = '''
if blind.exponent then
    local exponents = ""
    local exponents2 = ""
    for i = 1, blind.exponent[1] do
      exponents = exponents .. "^"
    end
    if blind.exponent[1] > 5 then
      exponents = ""
      exponents2 = "{" .. blind.exponent[1] .. "}"
    end
    blind_text[#blind_text + 1] =
      {n=G.UIT.R, config={align = "cm", emboss = 0.05, r = 0.1, minw = 2.5, padding = 0.07, colour = G.C.WHITE}, nodes={
        {n=G.UIT.R, config={align = "cm", maxw = 2.4}, nodes={
          {n=G.UIT.T, config={text = localize('ph_blind_score_at_least'), scale = 0.35, colour = G.C.UI.TEXT_DARK}},
        }},
        {n=G.UIT.R, config={align = "cm"}, nodes={
          {n=G.UIT.O, config={object = stake_sprite}},
          {n=G.UIT.T, config={text = exponents .. blind.exponent[2].. exponents2 .." "..localize('k_entr_base'), scale = 0.4, colour = G.C.RED}},
        }},
        {n=G.UIT.R, config={align = "cm"}, nodes={
          {n=G.UIT.T, config={text = localize('ph_blind_reward'), scale = 0.35, colour = G.C.UI.TEXT_DARK}},
          {n=G.UIT.O, config={object = DynaText({string = {_dollars and string.rep(localize('$'),_dollars) or '-'}, colours = {G.C.MONEY}, rotate = true, bump = true, silent = true, scale = 0.45})}},
        }},
        ability_text[1] and {n=G.UIT.R, config={align = "cm", padding = 0.08, colour = mix_colours(blind.boss_colour, G.C.GREY, 0.4), r = 0.1, emboss = 0.05, minw = 2.5, minh = 0.9}, nodes=ability_text} or nil
      }}
else
'''
match_indent = true


[[patches]]
[patches.pattern]
target = "engine/moveable.lua"
pattern = '''if self.alignment.type_list.b then'''
position = "before"
payload = '''
if not self.alignment then self.alignment = {} end
if not self.alignment.offset then self.alignment.offset = {} end
if not self.alignment.offset.y then self.alignment.offset.y = 0 end
'''
match_indent = true


[[patches]]
[patches.pattern]
target = '''=[SMODS _ "src/utils.lua"]'''
pattern = '''card_eval_status_text(scored_card, 'jokers', nil, percent, nil, {message = localize{type='variable',key= amount > 0 and 'a_xmult' or 'a_xmult_minus',vars={amount}}, Xmult_mod =  amount, colour =  G.C.EDITION, edition = true})'''
position = "at"
payload = '''
card_eval_status_text(scored_card, 'jokers', nil, percent, nil, {message = localize{type='variable',key= to_big(amount) > to_big(0) and 'a_xmult' or 'a_xmult_minus',vars={amount}}, Xmult_mod =  amount, colour =  G.C.EDITION, edition = true})
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "{n=G.UIT.T, config={text = localize('ph_blind_score_at_least'), scale = 0.3, colour = G.C.WHITE, shadow = true}}"
position = "at"
payload = "{n=G.UIT.T, config={text = localize('ph_blind_score_at_least'), scale = 0.3, colour = G.C.WHITE, shadow = true, id='score_at_least'}}"
match_indent = true

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.bonus = self.ability.bonus - old_center.config.bonus"
position = "at"
payload = "self.ability.bonus = (self.ability.bonus or 0) - (old_center.config.bonus or 0)"
match_indent = true

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "SC = Card(G.ROOM.T.w/2 - SC_scale*G.CARD_W/2, 10. + G.ROOM.T.h/2 - SC_scale*G.CARD_H/2, SC_scale*G.CARD_W, SC_scale*G.CARD_H, G.P_CARDS.empty, G.P_CENTERS['j_joker'])"
position = "after"
payload = '''
if ((Cryptid_config and Cryptid_config.menu) or false) then
	SC = Card(G.ROOM.T.w/2 - SC_scale*G.CARD_W/2, 10. + G.ROOM.T.h/2 - SC_scale*G.CARD_H/2, SC_scale*G.CARD_W, SC_scale*G.CARD_H, G.P_CARDS.empty, (G.GAME.EECardCharacter and G.P_CENTERS.j_entr_eecc or G.P_CENTERS.j_entr_surreal_joker),{bypass_discovery_center = true, bypass_discovery_ui = true})
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "card_character.lua"
pattern = 'self.children.card = Card(self.T.x, self.T.y, G.CARD_W, G.CARD_H, G.P_CARDS.empty, args.center or G.P_CENTERS.j_jolly, {bypass_discovery_center = true})'
position = "at"
payload = 'self.children.card = Card(self.T.x, self.T.y, G.CARD_W, G.CARD_H, G.P_CARDS.empty, args.center or (G.GAME.EECardCharacter and G.P_CENTERS.j_entr_eecc or G.P_CENTERS.j_entr_surreal_joker), {bypass_discovery_center = true})'
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = 'G.hand.highlighted[i].ability.discarded = true'
position = "at"
payload = '''
if not G.hand.highlighted[i].ability.scarred then 
  G.hand.highlighted[i].ability.discarded = true 
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "draw_card(G.hand, G.discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i])"
position = "at"
payload = '''
if not G.hand.highlighted[i].ability.scarred then 
  draw_card(G.hand, G.discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i]) 
  num = (num or 0) + 1
else 
  num = (num or 0) + 1
  overdraw = true
end 
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "SMODS.calculate_context({pre_discard = true, full_hand = G.hand.highlighted, hook = hook})"
position = "before"
payload = '''
local num
local overdraw
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "G.GAME.round_scores.cards_discarded.amt = G.GAME.round_scores.cards_discarded.amt + #cards"
position = "before"
payload = '''
if overdraw and num and num > 0 then G.FUNCS.draw_from_deck_to_hand(num) end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "if SMODS.saved then game_over = false end"
position = "at"
payload = '''
if Entropy.IsEE() and SMODS.saved then
    G.GAME.EECardCharacter = true
    G.GAME.EERevived = true
    G.STATE = G.STATES.GAME_OVER
    if not G.GAME.won and not G.GAME.seeded and not G.GAME.challenge then 
        G.PROFILES[G.SETTINGS.profile].high_scores.current_streak.amt = 0
    end
    G:save_settings()
    G.FILE_HANDLER.force = true
    G.STATE_COMPLETE = false
elseif SMODS.saved then game_over = false end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "if not G.GAME.won and not G.GAME.seeded and not G.GAME.challenge then "
position = "before"
payload = '''
if Entropy.IsEE() then
    G.GAME.EECardCharacter = true
end
'''
match_indent = true       

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''Jimbo:add_speech_bubble('lq_'..math.random(1,10), nil, {quip = true})'''
position = "at"
payload = '''
local text = (G.GAME.EECardCharacter and 'lq_ee_' or 'lq_')..math.random(1,10)
if G.GAME.EERevived then text = "lq_ee_revived" end
Jimbo:add_speech_bubble(text, nil, {quip = true})
G.GAME.EECardCharacter = nil
G.GAME.EERevived = nil
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if G.GAME.round_resets.ante <= G.GAME.win_ante then --Only add Jimbo to say a quip if the game over happens when the run is lost'''
position = "at"
payload = '''
if G.GAME.round_resets.ante <= G.GAME.win_ante or G.GAME.EECardCharacter then --Only add Jimbo to say a quip if the game over happens when the run is lost
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''    {n=G.UIT.R, config={align = "cm", padding = 0.08}, nodes={
      UIBox_button({button = 'exit_overlay_menu', label = {localize('b_endless')}, minw = 6.5, maxw = 5, minh = 1.2, scale = 0.7, shadow = true, colour = G.C.BLUE, focus_args = {nav = 'wide', button = 'x',set_button_pip = true}}),'''
position = "at"
payload = '''
    {n=G.UIT.R, config={align = "cm", padding = 0.08}, nodes={
      UIBox_button({button = 'exit_overlay_menu', label = {localize(G.GAME.TrueEndless and 'b_true_endless' or 'b_endless')}, minw = 6.5, maxw = 5, minh = 1.2, scale = 0.7, shadow = true, colour = G.C.BLUE, focus_args = {nav = 'wide', button = 'x',set_button_pip = true}}),
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''nominal_chips = self.base.nominal > 0 and self.base.nominal or nil,'''
position = "at"
payload = '''
nominal_chips = to_big(self.base.nominal) > to_big(0) and self.base.nominal or nil,
'''
match_indent = true